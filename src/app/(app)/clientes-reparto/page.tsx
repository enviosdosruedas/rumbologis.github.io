
"use client";

import React, { useState, useEffect, useCallback } from "react";
import { ClientesRepartoTable } from "@/components/clientes-reparto/clientes-reparto-table";
import { CreateClienteRepartoDialog } from "@/components/clientes-reparto/cliente-reparto-dialogs";
import type { ClienteReparto } from "@/types/cliente-reparto";
import type { Cliente } from "@/types/cliente";
import type { ClienteRepartoFormData } from "@/schemas/cliente-reparto-schema";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/lib/supabaseClient";
import { LoadingScaffold } from "@/components/layout/loading-scaffold";

export default function ClientesRepartoPage() {
  const [clientesReparto, setClientesReparto] = useState<ClienteReparto[]>([]);
  const [clientes, setClientes] = useState<Cliente[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const { toast } = useToast();

  const fetchClientes = useCallback(async () => {
    if (!supabase) {
      // This case should ideally not happen if Supabase is configured correctly.
      // Consider a global error state or redirect if Supabase is critical.
      console.error("Supabase client no disponible en fetchClientes.");
      toast({
        title: "Error de Configuración",
        description: "El cliente de Supabase no está disponible.",
        variant: "destructive",
      });
      setClientes([]);
      return false;
    }

    const { data, error } = await supabase
      .from("clientes")
      .select("*")
      .order("nombre", { ascending: true });

    if (error) {
      toast({
        title: "Error al Cargar Clientes Principales",
        description: error.message,
        variant: "destructive",
      });
      setClientes([]);
      return false;
    } else {
      setClientes(data as Cliente[] || []);
      return true;
    }
  }, [toast]);

  const fetchClientesReparto = useCallback(async () => {
    if (!supabase) {
      console.error("Supabase client no disponible en fetchClientesReparto.");
      toast({
        title: "Error de Configuración",
        description: "El cliente de Supabase no está disponible.",
        variant: "destructive",
      });
      setClientesReparto([]);
      return false;
    }
    // SELECT *, clientes ( nombre ) FROM clientes_reparto ORDER BY id ASC;
    // The select("*") will fetch all columns including the new 'telefono_reparto' if it exists in the DB.
    // It also fetches the 'id' generated by the database.
    // To fetch related client name: .select("*, cliente:clientes(nombre)") 
    // However, current implementation uses a client-side lookup via getClienteNombre in the table.
    const { data, error } = await supabase
      .from("clientes_reparto")
      .select("*") // This will include 'id' and 'telefono_reparto'
      .order("id", { ascending: true }); 

    if (error) {
      toast({
        title: "Error al Cargar Registros de Clientes Reparto",
        description: error.message,
        variant: "destructive",
      });
      setClientesReparto([]);
      return false;
    } else {
      setClientesReparto(data as ClienteReparto[] || []);
      return true;
    }
  }, [toast]);


  useEffect(() => {
    const loadInitialData = async () => {
        setIsLoading(true);
        await fetchClientes(); // Load main clients first
        await fetchClientesReparto(); // Then load delivery clients
        setIsLoading(false);
    }
    loadInitialData();
  }, [fetchClientes, fetchClientesReparto]);
  
  const handleCreateClienteReparto = async (formData: ClienteRepartoFormData) => {
    if (!supabase) {
      toast({ title: "Error de Configuración", description: "Supabase client no disponible.", variant: "destructive" });
      return;
    }
    
    // The 'id' field is not part of ClienteRepartoFormData, so Supabase will auto-generate it.
    const { data: newRecord, error } = await supabase
      .from("clientes_reparto")
      .insert([formData]) 
      .select()
      .single();

    if (error) {
      toast({
        title: "Error al Crear Registro de Cliente Reparto",
        description: error.message,
        variant: "destructive",
      });
    } else if (newRecord) {
      await fetchClientesReparto(); 
      toast({
        title: "Registro de Cliente Reparto Creado",
        description: `El registro para ${newRecord.nombre_reparto} ha sido creado exitosamente.`,
        variant: "default",
        className: "bg-accent text-accent-foreground"
      });
    }
  };

  const handleUpdateClienteReparto = async (id: number, formData: ClienteRepartoFormData) => {
     if (!supabase) {
      toast({ title: "Error de Configuración", description: "Supabase client no disponible.", variant: "destructive" });
      return;
    }

    const { data: updatedRecord, error } = await supabase
      .from("clientes_reparto")
      .update(formData) // formData includes the new 'telefono_reparto'
      .eq("id", id)
      .select()
      .single();
    
    if (error) {
      toast({
        title: "Error al Actualizar Registro de Cliente Reparto",
        description: error.message,
        variant: "destructive",
      });
    } else if (updatedRecord) {
      await fetchClientesReparto(); 
      toast({
        title: "Registro de Cliente Reparto Actualizado",
        description: `El registro para ${updatedRecord.nombre_reparto} ha sido actualizado exitosamente.`,
        variant: "default",
        className: "bg-accent text-accent-foreground"
      });
    }
  };

  const handleDeleteClienteReparto = async (id: number) => {
    if (!supabase) {
      toast({ title: "Error de Configuración", description: "Supabase client no disponible.", variant: "destructive" });
      return;
    }

    const recordToDelete = clientesReparto.find(cr => cr.id === id);

    const { error } = await supabase
      .from("clientes_reparto")
      .delete()
      .eq("id", id);

    if (error) {
      toast({
        title: "Error al Eliminar Registro de Cliente Reparto",
        description: error.message,
        variant: "destructive",
      });
    } else {
      await fetchClientesReparto(); 
      if (recordToDelete) {
        toast({
          title: "Registro de Cliente Reparto Eliminado",
          description: `El registro ${recordToDelete.nombre_reparto} ha sido eliminado.`,
          variant: "destructive",
        });
      } else {
        toast({
          title: "Registro de Cliente Reparto Eliminado",
          description: `El registro con ID ${id} ha sido eliminado.`,
          variant: "destructive",
        });
      }
    }
  };

  if (isLoading) {
    return (
      <LoadingScaffold
        pageTitle="Gestión de Clientes de Reparto"
        cardTitle="Configuraciones de Clientes para Reparto"
        loadingText="Cargando datos..."
      />
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-3xl font-bold tracking-tight">Gestión de Clientes de Reparto</h2>
        <CreateClienteRepartoDialog onCreate={handleCreateClienteReparto} clientes={clientes} />
      </div>
      <ClientesRepartoTable 
        clientesReparto={clientesReparto} 
        clientes={clientes} // Pass main clients for name lookup
        onUpdateClienteReparto={handleUpdateClienteReparto} 
        onDeleteClienteReparto={handleDeleteClienteReparto} 
      />
    </div>
  );
}
